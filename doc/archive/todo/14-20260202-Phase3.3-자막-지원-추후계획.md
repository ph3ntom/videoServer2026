# Phase 3.3: ìë§‰ ì§€ì› (ì¶”í›„ êµ¬í˜„ ì˜ˆì •)

**ë‚ ì§œ**: 2026-02-02
**ìƒíƒœ**: ğŸ“‹ ê³„íš ë‹¨ê³„ (ë³´ë¥˜)
**ìš°ì„ ìˆœìœ„**: Medium

---

## ğŸ¯ ëª©í‘œ

Netflix/YouTubeì™€ ê°™ì€ ë‹¤êµ­ì–´ ìë§‰ ì§€ì› êµ¬í˜„
- ë‹¤êµ­ì–´ ìë§‰ íŒŒì¼ ì—…ë¡œë“œ (.srt, .vtt)
- ìë§‰ ì„ íƒ UI
- video.js í”Œë ˆì´ì–´ì™€ í†µí•©

---

## ğŸ“‹ êµ¬í˜„ ê³„íš

### 1. ë°±ì—”ë“œ: ë°ì´í„°ë² ì´ìŠ¤ ëª¨ë¸

**ì‹ ê·œ í…Œì´ë¸”**: `video_subtitles`

```sql
CREATE TABLE video_subtitles (
    id SERIAL PRIMARY KEY,
    video_id INTEGER NOT NULL REFERENCES videos(id) ON DELETE CASCADE,
    language VARCHAR(10) NOT NULL,  -- ì–¸ì–´ ì½”ë“œ (ko, en, ja, zh)
    label VARCHAR(50) NOT NULL,     -- í‘œì‹œ ë¼ë²¨ (í•œêµ­ì–´, English, æ—¥æœ¬èª)
    file_path VARCHAR(500) NOT NULL, -- ìë§‰ íŒŒì¼ ê²½ë¡œ
    is_default BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_video_subtitles_video_id ON video_subtitles(video_id);
CREATE INDEX idx_video_subtitles_language ON video_subtitles(language);
```

**ëª¨ë¸ ì •ì˜**:
```python
# backend/app/models/subtitle.py
class VideoSubtitle(Base):
    __tablename__ = "video_subtitles"

    id = Column(Integer, primary_key=True)
    video_id = Column(Integer, ForeignKey("videos.id", ondelete="CASCADE"))
    language = Column(String(10), nullable=False)
    label = Column(String(50), nullable=False)
    file_path = Column(String(500), nullable=False)
    is_default = Column(Boolean, default=False)

    # Relationship
    video = relationship("Video", back_populates="subtitles")
```

### 2. ë°±ì—”ë“œ: ìë§‰ ì—…ë¡œë“œ API

**ì—”ë“œí¬ì¸íŠ¸**: `POST /videos/{video_id}/subtitles`

**ê¸°ëŠ¥**:
- ìë§‰ íŒŒì¼ ì—…ë¡œë“œ (.srt, .vtt í˜•ì‹)
- íŒŒì¼ ê²€ì¦ (í˜•ì‹, ì¸ì½”ë”©)
- ì–¸ì–´ ì½”ë“œ ë° ë¼ë²¨ ì§€ì •
- ê¸°ë³¸ ìë§‰ ì„¤ì •

**ê¶Œí•œ**:
- ë¹„ë””ì˜¤ ì—…ë¡œë” ë˜ëŠ” Adminë§Œ ì—…ë¡œë“œ ê°€ëŠ¥

**êµ¬í˜„ ì˜ˆì‹œ**:
```python
@router.post("/{video_id}/subtitles", status_code=status.HTTP_201_CREATED)
async def upload_subtitle(
    video_id: int,
    file: UploadFile = File(...),
    language: str = Form(...),  # "ko", "en", "ja", "zh"
    label: str = Form(...),     # "í•œêµ­ì–´", "English", "æ—¥æœ¬èª"
    is_default: bool = Form(False),
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Upload subtitle file for video

    - Allowed formats: .srt, .vtt
    - File size limit: 10MB
    - Encoding: UTF-8
    """
    # 1. ë¹„ë””ì˜¤ ì†Œìœ ì í™•ì¸
    video = await video_service.get_by_id(db, video_id)
    if not video:
        raise HTTPException(404, "Video not found")

    if video.user_id != current_user.id and current_user.role != UserRole.ADMIN:
        raise HTTPException(403, "Not authorized")

    # 2. íŒŒì¼ í˜•ì‹ ê²€ì¦
    file_ext = Path(file.filename).suffix.lower()
    if file_ext not in [".srt", ".vtt"]:
        raise HTTPException(400, "Invalid subtitle format. Use .srt or .vtt")

    # 3. íŒŒì¼ ì €ì¥
    subtitle_dir = Path(settings.UPLOAD_DIR) / "subtitles"
    subtitle_dir.mkdir(parents=True, exist_ok=True)

    unique_filename = f"{video.id}_{language}{file_ext}"
    file_path = subtitle_dir / unique_filename

    contents = await file.read()
    with open(file_path, "wb") as f:
        f.write(contents)

    # 4. DB ì €ì¥
    subtitle = VideoSubtitle(
        video_id=video_id,
        language=language,
        label=label,
        file_path=str(file_path),
        is_default=is_default
    )
    db.add(subtitle)
    await db.commit()

    return {"message": "Subtitle uploaded successfully", "subtitle_id": subtitle.id}
```

### 3. ë°±ì—”ë“œ: ìë§‰ ì¡°íšŒ ë° ì„œë¹™ API

**ì—”ë“œí¬ì¸íŠ¸**:
- `GET /videos/{video_id}/subtitles` - ìë§‰ ëª©ë¡ ì¡°íšŒ
- `GET /videos/{video_id}/subtitles/{subtitle_id}` - ìë§‰ íŒŒì¼ ë‹¤ìš´ë¡œë“œ
- `DELETE /videos/{video_id}/subtitles/{subtitle_id}` - ìë§‰ ì‚­ì œ (Owner/Admin)

**êµ¬í˜„ ì˜ˆì‹œ**:
```python
@router.get("/{video_id}/subtitles")
async def get_subtitles(
    video_id: int,
    db: AsyncSession = Depends(get_db)
):
    """Get all subtitles for a video"""
    result = await db.execute(
        select(VideoSubtitle).where(VideoSubtitle.video_id == video_id)
    )
    subtitles = result.scalars().all()

    return [{
        "id": s.id,
        "language": s.language,
        "label": s.label,
        "is_default": s.is_default,
        "url": f"/api/v1/videos/{video_id}/subtitles/{s.id}"
    } for s in subtitles]

@router.get("/{video_id}/subtitles/{subtitle_id}")
async def get_subtitle_file(
    video_id: int,
    subtitle_id: int,
    db: AsyncSession = Depends(get_db)
):
    """Serve subtitle file"""
    result = await db.execute(
        select(VideoSubtitle).where(
            VideoSubtitle.id == subtitle_id,
            VideoSubtitle.video_id == video_id
        )
    )
    subtitle = result.scalar_one_or_none()

    if not subtitle:
        raise HTTPException(404, "Subtitle not found")

    if not os.path.exists(subtitle.file_path):
        raise HTTPException(404, "Subtitle file not found")

    return FileResponse(
        subtitle.file_path,
        media_type="text/vtt" if subtitle.file_path.endswith(".vtt") else "text/plain",
        headers={"Access-Control-Allow-Origin": "*"}
    )
```

### 4. í”„ë¡ íŠ¸ì—”ë“œ: ìë§‰ ì—…ë¡œë“œ UI

**ìœ„ì¹˜**: VideoPlayer í˜ì´ì§€ ë˜ëŠ” ë³„ë„ ê´€ë¦¬ ì„¹ì…˜

**ê¸°ëŠ¥**:
- ë¹„ë””ì˜¤ ì—…ë¡œë”ë§Œ ì ‘ê·¼ ê°€ëŠ¥
- íŒŒì¼ ì„ íƒ (.srt, .vtt)
- ì–¸ì–´ ì„ íƒ ë“œë¡­ë‹¤ìš´ (í•œêµ­ì–´, English, æ—¥æœ¬èª, ä¸­æ–‡)
- ê¸°ë³¸ ìë§‰ ì²´í¬ë°•ìŠ¤
- ì—…ë¡œë“œ ì§„í–‰ë¥  í‘œì‹œ

**êµ¬í˜„ ì˜ˆì‹œ**:
```tsx
// frontend/src/components/SubtitleUpload.tsx
const SubtitleUpload: React.FC<{ videoId: number }> = ({ videoId }) => {
  const [file, setFile] = useState<File | null>(null);
  const [language, setLanguage] = useState('ko');
  const [label, setLabel] = useState('í•œêµ­ì–´');
  const [isDefault, setIsDefault] = useState(false);
  const [uploading, setUploading] = useState(false);

  const languageOptions = [
    { code: 'ko', label: 'í•œêµ­ì–´' },
    { code: 'en', label: 'English' },
    { code: 'ja', label: 'æ—¥æœ¬èª' },
    { code: 'zh', label: 'ä¸­æ–‡' }
  ];

  const handleUpload = async () => {
    if (!file) return;

    const formData = new FormData();
    formData.append('file', file);
    formData.append('language', language);
    formData.append('label', label);
    formData.append('is_default', String(isDefault));

    setUploading(true);
    try {
      await apiClient.post(`/videos/${videoId}/subtitles`, formData);
      alert('ìë§‰ì´ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.');
      setFile(null);
    } catch (error) {
      alert('ì—…ë¡œë“œ ì‹¤íŒ¨');
    } finally {
      setUploading(false);
    }
  };

  return (
    <div className="subtitle-upload">
      <h3>ìë§‰ ì—…ë¡œë“œ</h3>
      <input
        type="file"
        accept=".srt,.vtt"
        onChange={(e) => setFile(e.target.files?.[0] || null)}
      />
      <select value={language} onChange={(e) => setLanguage(e.target.value)}>
        {languageOptions.map(opt => (
          <option key={opt.code} value={opt.code}>{opt.label}</option>
        ))}
      </select>
      <label>
        <input
          type="checkbox"
          checked={isDefault}
          onChange={(e) => setIsDefault(e.target.checked)}
        />
        ê¸°ë³¸ ìë§‰ìœ¼ë¡œ ì„¤ì •
      </label>
      <button onClick={handleUpload} disabled={!file || uploading}>
        {uploading ? 'ì—…ë¡œë“œ ì¤‘...' : 'ì—…ë¡œë“œ'}
      </button>
    </div>
  );
};
```

### 5. í”„ë¡ íŠ¸ì—”ë“œ: video.js ìë§‰ í†µí•©

**ê¸°ëŠ¥**:
- ìë§‰ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
- video.js TextTrack API ì‚¬ìš©
- ìë§‰ ì„ íƒ UI (video.js ê¸°ë³¸ ì»¨íŠ¸ë¡¤ ì‚¬ìš©)

**êµ¬í˜„ ì˜ˆì‹œ**:
```tsx
// frontend/src/pages/VideoPlayer.tsx
useEffect(() => {
  if (!playerRef.current || !video) return;

  // Fetch subtitles
  const fetchSubtitles = async () => {
    const response = await apiClient.get(`/videos/${video.id}/subtitles`);
    const subtitles = response.data;

    // Add text tracks to video.js
    subtitles.forEach((subtitle: any) => {
      playerRef.current!.addRemoteTextTrack({
        kind: 'subtitles',
        src: subtitle.url,
        srclang: subtitle.language,
        label: subtitle.label,
        default: subtitle.is_default
      }, false);
    });
  };

  fetchSubtitles();
}, [video]);
```

**video.js ìë§‰ UI**:
- video.jsì˜ ê¸°ë³¸ CC ë²„íŠ¼ ì‚¬ìš©
- ì‚¬ìš©ìê°€ ìë§‰ On/Off í† ê¸€
- ì—¬ëŸ¬ ì–¸ì–´ ì¤‘ ì„ íƒ

---

## ğŸ› ï¸ ê¸°ìˆ  ìŠ¤íƒ

### ìë§‰ íŒŒì¼ í˜•ì‹
1. **SRT (SubRip Text)**
   - ê°€ì¥ ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” í˜•ì‹
   - í…ìŠ¤íŠ¸ ê¸°ë°˜, ê°„ë‹¨í•œ êµ¬ì¡°

   ```srt
   1
   00:00:01,000 --> 00:00:04,000
   ì•ˆë…•í•˜ì„¸ìš”

   2
   00:00:05,000 --> 00:00:08,000
   í™˜ì˜í•©ë‹ˆë‹¤
   ```

2. **WebVTT (Web Video Text Tracks)**
   - HTML5 í‘œì¤€
   - ë¸Œë¼ìš°ì € ë„¤ì´í‹°ë¸Œ ì§€ì›
   - ìŠ¤íƒ€ì¼ë§ ê°€ëŠ¥

   ```vtt
   WEBVTT

   00:00:01.000 --> 00:00:04.000
   ì•ˆë…•í•˜ì„¸ìš”

   00:00:05.000 --> 00:00:08.000
   í™˜ì˜í•©ë‹ˆë‹¤
   ```

### video.js TextTrack API
```javascript
// Add text track
player.addRemoteTextTrack({
  kind: 'subtitles',      // 'subtitles', 'captions', 'descriptions'
  src: '/path/to/subtitle.vtt',
  srclang: 'ko',          // Language code
  label: 'í•œêµ­ì–´',         // Display label
  default: true           // Default subtitle
}, false);

// Get all text tracks
const tracks = player.textTracks();

// Listen to track changes
player.textTracks().on('change', () => {
  console.log('Subtitle changed');
});
```

---

## ğŸ“Š íŒŒì¼ êµ¬ì¡°

```
/storage/
  â””â”€â”€ videos/
      â”œâ”€â”€ UUID.mp4                    # ë¹„ë””ì˜¤ íŒŒì¼
      â”œâ”€â”€ UUID_hls/                   # HLS ì„¸ê·¸ë¨¼íŠ¸
      â””â”€â”€ subtitles/
          â”œâ”€â”€ {video_id}_ko.srt       # í•œêµ­ì–´ ìë§‰
          â”œâ”€â”€ {video_id}_en.vtt       # ì˜ì–´ ìë§‰
          â”œâ”€â”€ {video_id}_ja.vtt       # ì¼ë³¸ì–´ ìë§‰
          â””â”€â”€ {video_id}_zh.srt       # ì¤‘êµ­ì–´ ìë§‰
```

---

## âš ï¸ ê³ ë ¤ì‚¬í•­

### 1. íŒŒì¼ ì¸ì½”ë”©
- ìë§‰ íŒŒì¼ì€ ë°˜ë“œì‹œ UTF-8 ì¸ì½”ë”©
- ì—…ë¡œë“œ ì‹œ ì¸ì½”ë”© ê²€ì¦ í•„ìš”
- ë³€í™˜ ë¡œì§ ì¶”ê°€ (ì„ íƒì‚¬í•­)

### 2. íŒŒì¼ í¬ê¸° ì œí•œ
- ìë§‰ íŒŒì¼ì€ ì¼ë°˜ì ìœ¼ë¡œ ì‘ìŒ (< 1MB)
- ìµœëŒ€ 10MB ì œí•œ ê¶Œì¥

### 3. ìë§‰ ë™ê¸°í™”
- ë¹„ë””ì˜¤ì™€ ìë§‰ íƒ€ì„ìŠ¤íƒ¬í”„ ì¼ì¹˜ í™•ì¸
- ìë™ ë™ê¸°í™” ê¸°ëŠ¥ (ê³ ê¸‰ ê¸°ëŠ¥, ì„ íƒì‚¬í•­)

### 4. ë³´ì•ˆ
- íŒŒì¼ ë‚´ìš© ê²€ì¦ (ì•…ì„± ì½”ë“œ ì‚½ì… ë°©ì§€)
- MIME type ê²€ì¦
- íŒŒì¼ í™•ì¥ì ê²€ì¦

---

## ğŸ”œ êµ¬í˜„ ë‹¨ê³„

1. **Phase 1: ë°±ì—”ë“œ ê¸°ë³¸ êµ¬í˜„**
   - VideoSubtitle ëª¨ë¸ ì¶”ê°€
   - ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰
   - ìë§‰ ì—…ë¡œë“œ/ì¡°íšŒ/ì‚­ì œ API

2. **Phase 2: í”„ë¡ íŠ¸ì—”ë“œ ì—…ë¡œë“œ UI**
   - ìë§‰ ì—…ë¡œë“œ ì»´í¬ë„ŒíŠ¸
   - íŒŒì¼ ê²€ì¦
   - ì§„í–‰ë¥  í‘œì‹œ

3. **Phase 3: video.js í†µí•©**
   - TextTrack API ì—°ë™
   - ìë§‰ ì„ íƒ UI
   - ê¸°ë³¸ ìë§‰ ìë™ í™œì„±í™”

4. **Phase 4: í…ŒìŠ¤íŠ¸ ë° ìµœì í™”**
   - ë‹¤ì–‘í•œ ìë§‰ í˜•ì‹ í…ŒìŠ¤íŠ¸
   - ì—¬ëŸ¬ ì–¸ì–´ í…ŒìŠ¤íŠ¸
   - ì„±ëŠ¥ ìµœì í™”

---

## ğŸ“ ì°¸ê³  ìë£Œ

- [video.js TextTrack Documentation](https://docs.videojs.com/tutorial-text-tracks.html)
- [WebVTT Specification](https://www.w3.org/TR/webvtt1/)
- [SRT Format Guide](https://en.wikipedia.org/wiki/SubRip)

---

**ì‘ì„±ì¼**: 2026-02-02
**ìƒíƒœ**: ğŸ“‹ ì¶”í›„ êµ¬í˜„ ì˜ˆì •
**ìš°ì„ ìˆœìœ„**: Medium
