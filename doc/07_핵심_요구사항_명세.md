# 07. 핵심 요구사항 명세

> 라즈베리파이 최적화: 핵심 기능 상세 구현 가이드

## 프로젝트 특성

본 프로젝트는 **라즈베리파이 기반 경량 스트리밍 플랫폼**을 목표로 합니다.
- **인프라**: 라즈베리파이 4B/5 (8GB RAM), 단일 Docker 컨테이너
- **UI/UX**: YouTube 스타일 격자 레이아웃, Netflix 스타일 다크 모드
- **배포 방식**: CasaOS 커스텀 앱, Docker Compose
- 다음 핵심 요구사항을 만족해야 합니다.

---

## 1. 권한 및 비디오 등록 (핵심 요구사항)

### 요구사항
- **비디오 등록은 관리자(Admin)만 가능**
- 일반 사용자(user)는 비디오 시청 및 검색만 가능
- 프리미엄 사용자(premium)는 프리미엄 콘텐츠 접근 (Phase 3)
- 사용자 역할 구분: `user`, `admin`, `premium`

### 구현 세부사항

#### 데이터베이스
```sql
-- users 테이블의 role 컬럼
role VARCHAR(20) DEFAULT 'user' CHECK (role IN ('user', 'admin', 'premium'))
```

#### API 권한
- **비디오 업로드/수정/삭제 API**: `admin` 역할만 접근 가능
- **비디오 조회/스트리밍 API**: 모든 인증된 사용자 접근 가능

#### 백엔드 구현
```python
# app/api/deps.py
async def get_current_admin(
    current_user: User = Depends(get_current_user)
) -> User:
    if current_user.role != "admin":
        raise HTTPException(
            status_code=403,
            detail="Admin access required"
        )
    return current_user

# app/api/v1/videos.py
@router.post("/")
async def create_video(
    current_admin: User = Depends(get_current_admin),  # admin만 가능
    ...
):
    ...
```

#### 프론트엔드
- 일반 사용자에게는 "업로드" 버튼 숨김
- 관리자 전용 페이지 라우팅 보호

---

## 2. 고급 태그 조합 검색 (최우선 핵심 기능)

### 요구사항
- 여러 태그를 조합하여 검색 가능
- **포함(+) 조건**: 반드시 포함되어야 하는 태그
- **제외(-) 조건**: 제외되어야 하는 태그
- **예시**: `한국영화 + 공상과학 - 전쟁영화`
  - 한국영화 태그가 있고
  - 공상과학 태그가 있으며
  - 전쟁영화 태그가 없는 비디오만 검색

### 구현 세부사항

#### API 엔드포인트
```
GET /api/v1/search/videos/advanced
```

#### Query Parameters
```
include_tags: 포함할 태그 slug 목록 (쉼표 구분)
exclude_tags: 제외할 태그 slug 목록 (쉼표 구분)
```

#### 요청 예시
```
GET /api/v1/search/videos/advanced?include_tags=korean-movie,sci-fi&exclude_tags=war-movie
```

#### SQL 쿼리 로직
```sql
-- 포함 태그: korean-movie, sci-fi
-- 제외 태그: war-movie

SELECT DISTINCT v.*
FROM videos v
-- 한국영화 태그 포함
INNER JOIN video_tags vt1 ON v.id = vt1.video_id
INNER JOIN tags t1 ON vt1.tag_id = t1.id AND t1.slug = 'korean-movie'
-- 공상과학 태그 포함
INNER JOIN video_tags vt2 ON v.id = vt2.video_id
INNER JOIN tags t2 ON vt2.tag_id = t2.id AND t2.slug = 'sci-fi'
-- 전쟁영화 제외
WHERE v.id NOT IN (
    SELECT vt3.video_id
    FROM video_tags vt3
    INNER JOIN tags t3 ON vt3.tag_id = t3.id
    WHERE t3.slug = 'war-movie'
)
AND v.status = 'ready'
AND v.published_at IS NOT NULL
ORDER BY v.published_at DESC;
```

#### 백엔드 구현 (Python)
```python
# app/services/search_service.py
async def advanced_tag_search(
    db: Session,
    include_tags: List[str],
    exclude_tags: List[str] = None
) -> List[Video]:
    query = db.query(Video)

    # 포함 태그 필터링
    for tag_slug in include_tags:
        query = query.join(VideoTag).join(Tag).filter(
            Tag.slug == tag_slug
        )

    # 제외 태그 필터링
    if exclude_tags:
        excluded_video_ids = (
            db.query(VideoTag.video_id)
            .join(Tag)
            .filter(Tag.slug.in_(exclude_tags))
            .subquery()
        )
        query = query.filter(~Video.id.in_(excluded_video_ids))

    query = query.filter(
        Video.status == 'ready',
        Video.published_at.isnot(None)
    )

    return query.distinct().all()
```

#### 프론트엔드 구현
```typescript
// 태그 선택 UI
interface TagFilter {
  includeTags: string[];  // ['+한국영화', '+공상과학']
  excludeTags: string[];  // ['-전쟁영화']
}

// 검색 요청
const searchVideos = async (filter: TagFilter) => {
  const params = new URLSearchParams();
  if (filter.includeTags.length > 0) {
    params.append('include_tags', filter.includeTags.join(','));
  }
  if (filter.excludeTags.length > 0) {
    params.append('exclude_tags', filter.excludeTags.join(','));
  }

  const response = await api.get(`/search/videos/advanced?${params}`);
  return response.data;
};
```

#### UI/UX 디자인
1. **태그 선택 인터페이스 (체크박스 + 연산자)**
   - 각 태그마다:
     - 체크박스 (선택/미선택)
     - 연산자 드롭다운 또는 라디오 버튼: "포함" / "제외"
   - 예시 UI:
     ```
     ☑ 한국영화    (○ 포함  ○ 제외)
     ☑ 공상과학    (○ 포함  ○ 제외)
     ☑ 전쟁영화    (○ 포함  ● 제외)
     ```
   - 체크된 태그만 검색 쿼리에 포함

2. **검색 결과 표시**
   - 적용된 필터 표시: `한국영화 ✓, 공상과학 ✓, 전쟁영화 ✗`
   - 필터 초기화 버튼

---

## 3. 썸네일 관리 및 미리보기 (핵심 기능)

### 요구사항

#### 3.1 썸네일 선택 기능
- 비디오 업로드 시 자동으로 여러 썸네일 생성
- 관리자가 원하는 썸네일 선택 가능
- 외부 이미지 파일을 썸네일로 업로드 가능

#### 3.2 썸네일 호버 미리보기
- 사용자가 비디오 썸네일에 마우스를 올리면
- 여러 썸네일이 순차적으로 표시되어 영상 미리보기 효과

### 구현 세부사항

#### 3.1.1 자동 썸네일 생성 (장면 전환 감지)

**비디오 업로드 플로우:**
1. 관리자가 비디오 업로드
2. 백엔드가 FFmpeg로 **10-15개의 썸네일 자동 생성** (장면 전환 감지 방식)
   - **장면 전환 감지**: `select='gt(scene,0.3)'` 필터 사용
   - 균등 간격 방식이 아닌 **줄거리 내용이 예상되는** 방식
   - WebP 형식 (320x180), JPEG 대비 30% 용량 절약
3. `video_thumbnails` 테이블에 저장
4. 첫 번째 썸네일을 기본 선택 (`is_selected = TRUE`)

**FFmpeg 명령어 (장면 전환 감지):**
```bash
# 장면 전환 감지 방식 (scene change detection)
ffmpeg -i input.mp4 \
  -vf "select='gt(scene,0.3)',scale=320:180" \
  -vsync 0 \
  -f image2 \
  /mnt/thumbnails/{video_id}/thumb_%03d.webp

# 설명:
# - select='gt(scene,0.3)': 장면 변화가 30% 이상일 때만 추출
# - scale=320:180: 썸네일 크기 (라즈베리파이 최적화)
# - vsync 0: 중복 프레임 제거
# - webp: JPEG 대비 30% 용량 절약
```

**백엔드 구현:**
```python
# app/utils/video_processor.py
import subprocess
import os

async def generate_thumbnails(video_path: str, video_id: int, duration: int):
    """비디오에서 장면 전환 감지로 썸네일 생성"""
    thumbnail_dir = f"/mnt/thumbnails/{video_id}/"
    os.makedirs(thumbnail_dir, exist_ok=True)

    output_pattern = f"{thumbnail_dir}thumb_%03d.webp"

    # FFmpeg 실행 (장면 전환 감지)
    cmd = [
        'ffmpeg', '-i', video_path,
        '-vf', "select='gt(scene,0.3)',scale=320:180",
        '-vsync', '0',
        '-f', 'image2',
        output_pattern
    ]
    subprocess.run(cmd, check=True, capture_output=True)

    # 생성된 파일 목록 수집
    thumbnails = []
    for filename in sorted(os.listdir(thumbnail_dir)):
        if filename.startswith('thumb_') and filename.endswith('.webp'):
            file_path = os.path.join(thumbnail_dir, filename)
            # 타임스탬프 추정 (파일 생성 순서 기반)
            timestamp = len(thumbnails) * (duration // 15)

            thumbnails.append({
                'file_path': file_path,
                'timestamp': timestamp,
                'is_auto_generated': True
            })

    # 최대 15개로 제한 (라즈베리파이 성능 고려)
    return thumbnails[:15]

# app/services/video_service.py
async def process_video_upload(video_id: int, file_path: str):
    # 메타데이터 추출
    metadata = extract_video_metadata(file_path)

    # 썸네일 생성
    thumbnails = await generate_thumbnails(
        file_path,
        video_id,
        metadata['duration']
    )

    # DB에 저장
    for thumb in thumbnails:
        await create_video_thumbnail(
            video_id=video_id,
            file_path=thumb['file_path'],
            timestamp=thumb['timestamp'],
            is_auto_generated=True,
            is_selected=(thumbnails.index(thumb) == 0)  # 첫 번째를 기본 선택
        )
```

#### 3.1.2 관리자 썸네일 선택

**API 엔드포인트:**
```
GET  /api/v1/admin/videos/{video_id}/thumbnails  # 썸네일 목록 조회
POST /api/v1/admin/videos/{video_id}/thumbnails  # 외부 이미지 업로드
PUT  /api/v1/admin/videos/{video_id}/thumbnails/{thumbnail_id}/select  # 썸네일 선택
```

**썸네일 선택 API:**
```python
@router.put("/{video_id}/thumbnails/{thumbnail_id}/select")
async def select_thumbnail(
    video_id: int,
    thumbnail_id: int,
    current_admin: User = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    # 기존 선택 해제
    await db.execute(
        update(VideoThumbnail)
        .where(VideoThumbnail.video_id == video_id)
        .values(is_selected=False)
    )

    # 새로 선택
    await db.execute(
        update(VideoThumbnail)
        .where(VideoThumbnail.id == thumbnail_id)
        .values(is_selected=True)
    )

    # videos 테이블의 thumbnail_path 업데이트
    thumbnail = await db.get(VideoThumbnail, thumbnail_id)
    await db.execute(
        update(Video)
        .where(Video.id == video_id)
        .values(thumbnail_path=thumbnail.file_path)
    )

    await db.commit()
    return {"message": "Thumbnail selected"}
```

**프론트엔드 - 관리자 페이지:**
```tsx
// ThumbnailSelector.tsx
const ThumbnailSelector = ({ videoId }) => {
  const [thumbnails, setThumbnails] = useState([]);

  useEffect(() => {
    fetchThumbnails(videoId).then(setThumbnails);
  }, [videoId]);

  const handleSelect = async (thumbnailId) => {
    await api.put(`/admin/videos/${videoId}/thumbnails/${thumbnailId}/select`);
    // 썸네일 목록 재로드
  };

  return (
    <div className="thumbnail-grid">
      {thumbnails.map(thumb => (
        <div
          key={thumb.id}
          className={thumb.is_selected ? 'selected' : ''}
          onClick={() => handleSelect(thumb.id)}
        >
          <img src={thumb.file_path} alt={`${thumb.timestamp}s`} />
          <span>{thumb.timestamp}s</span>
          {thumb.is_selected && <CheckIcon />}
        </div>
      ))}
    </div>
  );
};
```

#### 3.2 썸네일 호버 미리보기

**프론트엔드 구현:**
```tsx
// VideoCard.tsx
const VideoCard = ({ video }) => {
  const [currentThumbIndex, setCurrentThumbIndex] = useState(0);
  const [isHovering, setIsHovering] = useState(false);
  const [thumbnails, setThumbnails] = useState([]);
  const intervalRef = useRef(null);

  // 마우스 호버 시 썸네일 로드
  const handleMouseEnter = async () => {
    setIsHovering(true);

    // 썸네일 목록 가져오기 (공개 API)
    const thumbs = await api.get(`/videos/${video.id}/thumbnails`);
    setThumbnails(thumbs.data);

    // 1초마다 썸네일 변경 (자연스러운 미리보기)
    intervalRef.current = setInterval(() => {
      setCurrentThumbIndex(prev => (prev + 1) % thumbs.data.length);
    }, 1000);
  };

  const handleMouseLeave = () => {
    setIsHovering(false);
    setCurrentThumbIndex(0);
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
  };

  return (
    <div
      className="video-card"
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      <img
        src={
          isHovering && thumbnails.length > 0
            ? thumbnails[currentThumbIndex].file_path
            : video.thumbnail_path
        }
        alt={video.title}
        className="thumbnail"
      />
      <h3>{video.title}</h3>
    </div>
  );
};
```

**최적화:**
1. **썸네일 프리로드**: 첫 호버 시 모든 썸네일 이미지 캐싱
2. **Lazy Loading**: 뷰포트에 보이는 카드만 미리보기 활성화
3. **Debouncing**: 빠른 호버 이동 시 불필요한 API 호출 방지

---

## 4. Docker 배포 (낮은 우선순위)

### 요구사항
- Jellyfin처럼 Docker 이미지로 배포 가능
- 한 번의 명령어로 전체 스택 실행

### 구현 계획 (Phase 3)

#### Docker Compose 구성
```yaml
# docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:14
    environment:
      POSTGRES_DB: streamflix
      POSTGRES_USER: streamflix
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data

  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      DATABASE_URL: postgresql://streamflix:${DB_PASSWORD}@postgres/streamflix
    volumes:
      - ./uploads:/app/uploads
    depends_on:
      - postgres

  frontend:
    build: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - backend

volumes:
  postgres_data:
```

---

## 우선순위 요약

### 최우선 (Phase 1)
1. ✅ **관리자 전용 비디오 등록** - 권한 시스템
2. ✅ **고급 태그 조합 검색** - 포함/제외 필터링
3. ✅ **썸네일 자동 생성 및 선택**
4. ✅ **썸네일 호버 미리보기**

### 중간 우선순위 (Phase 2)
- 태그 관리 UI
- 검색 결과 정렬/필터링
- 썸네일 최적화

### 낮은 우선순위 (Phase 3)
- Docker 이미지 배포
- CI/CD 파이프라인

---

## 성공 기준

### 태그 검색 기능
- [ ] 2개 이상의 포함 태그로 검색 가능
- [ ] 1개 이상의 제외 태그로 필터링 가능
- [ ] 검색 결과가 1초 이내에 반환
- [ ] 검색 결과 정확도 100%

### 썸네일 기능
- [ ] 업로드 시 자동으로 5-10개의 썸네일 생성
- [ ] 관리자가 원하는 썸네일 선택 가능
- [ ] 호버 시 0.5초 간격으로 썸네일 변경
- [ ] 썸네일 로딩 시간 < 200ms

### 권한 관리
- [ ] 일반 사용자는 비디오 업로드 불가
- [ ] 관리자만 비디오 CRUD 가능
- [ ] 권한 없는 접근 시 403 에러 반환
